<!DOCTYPE html>
<html lang="zh-cmn-Hans">

<head>
  <meta charset="UTF-8">
  <title>JavaScript面向对象-设计模式</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="https://rawgit.com/blade254353074/FED-Learn-Path/gh-pages/assets/css/libs/normalize.css">
  <link rel="stylesheet" href="https://rawgit.com/blade254353074/FED-Learn-Path/gh-pages/assets/css/components/examples.css">
  <link rel="stylesheet" href="https://rawgit.com/blade254353074/FED-Learn-Path/gh-pages/assets/css/components/prettify.css">
  <style>

  </style>
</head>

<body onload="prettyPrint()">
  <h1 class="exp-title">JavaScript面向对象-设计模式</h1>
  <div class="exp-container">
    <div class="exp-wrap">
      <p>本页内容根据《JavaScript高级程序设计（第3版）》精炼而成</p>
      <p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这写方式有个明显的缺点：使用同一个接创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>
      <ul>
        <li>工厂模式</li>
        <li>构造函数模式</li>
        <li>原型模式</li>
        <li>组合使用构造函数模式和原型模式</li>
        <li>动态原型模式</li>
        <li>寄生构造函数模式</li>
        <li>稳妥构造函数模式</li>
      </ul>
    </div>
  </div>
  <div class="exp-container">
    <h3 class="exp-title-sub">工厂模式</h3>
    <div class="exp-stage">
      <p>工厂模式抽象了创建具体对象的过程。考虑到 ES6- 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
      <pre class="prettyprint">
function createPerson(name, age, job) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    alert(this.name);
  };
  return o;
}
var person1 = createPerson('a', 22, 'F2E');
var person2 = createPerson('b', 20, 'PM');</pre>
      <p>调用createPerson()，返回包含3个属性1个方法的对象</p>
      <p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新的模式出现了。</p>
    </div>
  </div>
  <div class="exp-container">
    <h3 class="exp-title-sub">构造函数模式</h3>
    <div class="exp-stage">
      <p>ES中的构造函数可用来创建特定类型的对象。像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下：</p>
      <pre class="prettyprint">
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    alert(this.name);
  };
}
var person1 = new Person('a', 22, 'F2E');
var person2 = new Person('b', 20, 'PM');</pre>
      <p>特点：</p>
      <ul>
        <li>没有显式地创建对象</li>
        <li>直接将属性和方法赋给了this对象</li>
        <li>没有 return 语句</li>
      </ul>
      <p>按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</p>
      <p>创建 Person 的新示例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p>
      <ol>
        <li>创建一个新的对象</li>
        <li>将构造函数的作用域赋给新对象</li>
        <li>执行构造函数中的代码（为这个新对象添加属性）</li>
        <li>返回新的对象</li>
      </ol>
      <pre class="prettyprint">
// 新创建的对象有一个 constructor （构造函数）属性，该属性指向 Person
person1.constructor === Person; // true
person2.constructor === Person; // true
// 对象的 constructor 属性最初使用来标识对象类型的。
// 但是，检测对象类型，还是 instanceof 操作符更可靠一些。
// 新创建的对象既是 Object 的示例，同时也是 Person 的实例
person1 instanceof Object; // true
person1 instanceof Person; // true</pre>
      <p>创建自定义的构造函数意味着将来可以<strong>将它的实例标识为一种特定的类型</strong>；这正是构造函数模式胜过工厂模式的地方。</p>
      <ol>
        <li>
          <h4>将构造函数当作函数</h4>
          <p>任何函数，只要通过 new 操作符来调用，那他就可以作为构造函数；而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样</p>
          <pre class="prettyprint">
// 当作构造函数使用
var person = new Person('a', 22, 'F2E');
person.sayName(); // "a"
// 作为普通函数调用
Person('b', 20, 'PM'); // 函数中的 this === window
window.sayName(); // "b"
// 在另一个对象的作用域中调用
var o = new Object();
Person.call(o, 'c', 23, 'CEO');
o.sayName(); // "c"</pre>
        </li>
        <li>
          <h4>构造函数的问题</h4>
          <p>构造函数的主要问题，就是每个方法就要在每个实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 sayName() 的方法，但那辆个方法不是同一个 Function 的实例。</p>
          <p>也就是说 person1.sayName 与 person2.sayName 是两个不同的 Function 实例。然而，创建两个作用相同的实例没有必要，况且有 this 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。</p>
          <p>因此，可以像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。</p>
          <pre class="prettyprint">
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName;
}

function sayName() {
  alert(this.name);
}
var person1 = new Person('a', 22, 'F2E');
var person2 = new Person('b', 20, 'PM');</pre>
          <p>如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，这些问题可以通过使用原型模式来解决。</p>
        </li>
      </ol>
    </div>
  </div>
  <div class="exp-container">
    <h3 class="exp-title-sub">原型模式</h3>
    <div class="exp-stage">
      <p>每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的属性和方法可以由所有对象实例共享。</p>
      <p>换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中：</p>
      <pre class="prettyprint">
function Person() {}
Person.prototype.name = 'x';
Person.prototype.age = 22;
Person.prototype.job = 'CEO';
Person.prototype.sayName = function() {
  alert(this.name);
};

var person1 = new Person();
person1.sayName(); // "x"
var person2 = new Person();

person1.sayName === person2.sayName; // true</pre>
      <p>与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。</p>
      <ol>
        <li>
          <h4>理解原型对象</h4>
          <p>创建一个新函数，该函数会有一个 prototype 属性指向函数的原型对象。原型对象会有一个 constructor（构造函数）属性，这个属性指向这个新函数。</p>
          <p>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性，至于其他方法，则都是从 Object 继承而来的。</p>
          <p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫 [[Prototype]]。虽然在脚本中没有标准的方式访问 [[Prototype]]，但 FF、Safari 和 Chrome 在每个对象上都支持一个属性 __proto__。</p>
          <a href="https://raw.githubusercontent.com/blade254353074/FED-Learn-Path/gh-pages/assets/imgs/prototype1.png" target="_blank"><img src="https://raw.githubusercontent.com/blade254353074/FED-Learn-Path/gh-pages/assets/imgs/prototype1.png"/></a>
          <p class="exp-center">各个对象之间的关系</p>
          <p>Person的实例 —— person1 与 person2 都包含一个属性，指向 Person.prototype，它们与构造函数没有直接的关系。这两个实例都不包含属性和方法，但我们却可以调用 person1.sayName()，这是通过查找对象属性的过程来实现的。</p>
          <pre class="prettyprint">
/*
   虽然所有实现中都无法访问到 [[Prototype]]，但可以
   通过 isPrototypeOf() 方法来确定对象之间是否存在这种关系。
   如果[[Prototype]]指向 Person.prototype，那么这个方法就返回 true
*/
Person.prototype.isPrototypeOf(person1); // true
Person.prototype.isPrototypeOf(person2); // true
// ES5 的方法 Object.getPrototypeOf()，可以返回 [[Prototype]] 的值
Object.getPrototypeOf(person1) == Person.prototype; // true
Object.getPrototypeOf(person1).name; // "x"</pre>
          <p><strong>JS引擎查找对象属性的过程：实例 - 原型对象 - undefined。</strong>这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p>
          <p>在对象实例中不可以重写原型中的值。如果向实例中添加了一个与原型中同名的属性，那么就会在实例中创建该属性，该属性则会“屏蔽”原型中的那个属性。</p>
          <pre class="prettyprint">
var person1 = new Person();
var person2 = new Person();

person1.name = 'b';
person1.name; // "b" ——来自实例
person2.name; // "x" ——来自原型
delete person1.name;
person1.name; // "x" ——来自原型</pre>
          <p>用 delete 操作符删除实例中的属性后，“屏蔽”也就消失了，再访问该属性时就是原型中的值了。</p>
          <p>Object 的 hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是原型中。这个方法只在给定属性存在于对象实例中，才会返回 true 。</p>
          <pre class="prettyprint">
var person1 = new Person();
var person2 = new Person();

person1.hasOwnProperty('name'); // false 即属性来自原型
person1.name = 'b'; // 创建实例属性
person1.hasOwnProperty('name'); // true 即属性来自实例</pre>
        </li>
        <li>
          <h4>原型与 in 操作符</h4>
          <p> in 操作符有两种用法：for-in循环，单独使用。单独使用时，'name' in object 可以访问到属性时返回 true ，无论属性存在于实例还是原型中。</p>
          <p>利用 in 和 hasOwnProperty() 方法，可以确定该属性是否存在于原型中：</p>
          <pre class="prettyprint">
// 检测属性是否是来自于原型
function hasPrototypeProperty(object, name) {
  // 判断属性是否存在于对象实例中
  // 存在则直接返回 false;
  // 不存在，则再判断是否（原型中）可以访问到该属性
  // 可访问到，返回 true,
  return !object.hasOwnProperty(name) && (name in object);
}
var person = new Person();
hasPrototypeProperty(person, 'name'); // true
person.name = 'b';
hasPrototypeProperty(person, 'name'); // false</pre>
          <p>使用ES5的 Object.keys() 可取得对象上所有可枚举的实例属性，此方法接受一个对象参数，返回字符串数组。<br>使用ES5的 Object.getOwnPropertyNames() 可取得对象上所有的实例属性。</p>
        </li>
      </ol>
    </div>
  </div>

  <script src="https://rawgit.com/blade254353074/FED-Learn-Path/gh-pages/assets/js/libs/prettify.js"></script>
</body>

</html>
