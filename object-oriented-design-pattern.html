<!DOCTYPE html>
<html lang="zh-cmn-Hans">

<head>
  <meta charset="UTF-8">
  <title>JavaScript面向对象-设计模式</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="https://rawgit.com/blade254353074/FED-Learn-Path/gh-pages/assets/css/libs/normalize.css">
  <link rel="stylesheet" href="https://rawgit.com/blade254353074/FED-Learn-Path/gh-pages/assets/css/components/examples.css">
  <link rel="stylesheet" href="https://rawgit.com/blade254353074/FED-Learn-Path/gh-pages/assets/css/components/prettify.css">
  <style>

  </style>
</head>

<body onload="prettyPrint()">
  <h1 class="exp-title">JavaScript面向对象-设计模式</h1>
  <div class="exp-container">
    <div class="exp-wrap">
      <p>本页内容根据《JavaScript高级程序设计（第3版）》精炼而成</p>
      <p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这写方式有个明显的缺点：使用同一个接创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>
      <ul>
        <li><a href="#factoryMode">工厂模式</a></li>
        <li><a href="#constructorMode">构造函数模式</a></li>
        <li><a href="#prototypeMode">原型模式</a></li>
        <li><a href="#constructor_prototypeMixed">组合使用构造函数模式和原型模式</a></li>
      </ul>
    </div>
  </div>
  <div id="factoryMode" class="exp-container">
    <h3 class="exp-title-sub">工厂模式</h3>
    <div class="exp-stage">
      <p>工厂模式抽象了创建具体对象的过程。考虑到 ES6- 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
      <pre class="prettyprint">
function createPerson(name, age, job) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    alert(this.name);
  };
  return o;
}
var person1 = createPerson('a', 22, 'F2E');
var person2 = createPerson('b', 20, 'PM');</pre>
      <p>调用createPerson()，返回包含3个属性1个方法的对象</p>
      <p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新的模式出现了。</p>
    </div>
  </div>
  <div id="constructorMode" class="exp-container">
    <h3 class="exp-title-sub">构造函数模式</h3>
    <div class="exp-stage">
      <p>ES中的构造函数可用来创建特定类型的对象。像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下：</p>
      <pre class="prettyprint">
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    alert(this.name);
  };
}
var person1 = new Person('a', 22, 'F2E');
var person2 = new Person('b', 20, 'PM');</pre>
      <p>特点：</p>
      <ul>
        <li>没有显式地创建对象</li>
        <li>直接将属性和方法赋给了this对象</li>
        <li>没有 return 语句</li>
      </ul>
      <p>按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</p>
      <p>创建 Person 的新示例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p>
      <ol>
        <li>创建一个新的对象</li>
        <li>将构造函数的作用域赋给新对象</li>
        <li>执行构造函数中的代码（为这个新对象添加属性）</li>
        <li>返回新的对象</li>
      </ol>
      <pre class="prettyprint">
// 新创建的对象有一个 constructor （构造函数）属性，该属性指向 Person
person1.constructor === Person; // true
person2.constructor === Person; // true
// 对象的 constructor 属性最初使用来标识对象类型的。
// 但是，检测对象类型，还是 instanceof 操作符更可靠一些。
// 新创建的对象既是 Object 的示例，同时也是 Person 的实例
person1 instanceof Object; // true
person1 instanceof Person; // true</pre>
      <p>创建自定义的构造函数意味着将来可以<strong>将它的实例标识为一种特定的类型</strong>；这正是构造函数模式胜过工厂模式的地方。</p>
      <ol>
        <li>
          <h4>将构造函数当作函数</h4>
          <p>任何函数，只要通过 new 操作符来调用，那他就可以作为构造函数；而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样</p>
          <pre class="prettyprint">
// 当作构造函数使用
var person = new Person('a', 22, 'F2E');
person.sayName(); // "a"
// 作为普通函数调用
Person('b', 20, 'PM'); // 函数中的 this === window
window.sayName(); // "b"
// 在另一个对象的作用域中调用
var o = new Object();
Person.call(o, 'c', 23, 'CEO');
o.sayName(); // "c"</pre>
        </li>
        <li>
          <h4>构造函数的问题</h4>
          <p>构造函数的主要问题，就是每个方法就要在每个实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 sayName() 的方法，但那辆个方法不是同一个 Function 的实例。</p>
          <p>也就是说 person1.sayName 与 person2.sayName 是两个不同的 Function 实例。然而，创建两个作用相同的实例没有必要，况且有 this 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。</p>
          <p>因此，可以像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。</p>
          <pre class="prettyprint">
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName;
}

function sayName() {
  alert(this.name);
}
var person1 = new Person('a', 22, 'F2E');
var person2 = new Person('b', 20, 'PM');</pre>
          <p>如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，这些问题可以通过使用原型模式来解决。</p>
        </li>
      </ol>
    </div>
  </div>
  <div id="prototypeMode" class="exp-container">
    <h3 class="exp-title-sub">原型模式</h3>
    <div class="exp-stage">
      <p>每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的属性和方法可以由所有对象实例共享。</p>
      <p>换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中：</p>
      <pre class="prettyprint">
function Person() {}
Person.prototype.name = 'x';
Person.prototype.age = 22;
Person.prototype.job = 'CEO';
Person.prototype.sayName = function() {
  alert(this.name);
};

var person1 = new Person();
person1.sayName(); // "x"
var person2 = new Person();

person1.sayName === person2.sayName; // true</pre>
      <p>与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。</p>
      <ol>
        <li>
          <h4>理解原型对象</h4>
          <p>创建一个新函数，该函数会有一个 prototype 属性指向函数的原型对象。原型对象会有一个 constructor（构造函数）属性，这个属性指向这个新函数。</p>
          <p>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性，至于其他方法，则都是从 Object 继承而来的。</p>
          <p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫 [[Prototype]]。虽然在脚本中没有标准的方式访问 [[Prototype]]，但 FF、Safari 和 Chrome 在每个对象上都支持一个属性 __proto__。</p>
          <a href="https://raw.githubusercontent.com/blade254353074/FED-Learn-Path/gh-pages/assets/imgs/prototype1.png" target="_blank"><img src="https://raw.githubusercontent.com/blade254353074/FED-Learn-Path/gh-pages/assets/imgs/prototype1.png"/></a>
          <p class="exp-center">各个对象之间的关系</p>
          <p>Person的实例 —— person1 与 person2 都包含一个属性，指向 Person.prototype，它们与构造函数没有直接的关系。这两个实例都不包含属性和方法，但我们却可以调用 person1.sayName()，这是通过查找对象属性的过程来实现的。</p>
          <pre class="prettyprint">
/*
   虽然所有实现中都无法访问到 [[Prototype]]，但可以
   通过 isPrototypeOf() 方法来确定对象之间是否存在这种关系。
   如果[[Prototype]]指向 Person.prototype，那么这个方法就返回 true
*/
Person.prototype.isPrototypeOf(person1); // true
Person.prototype.isPrototypeOf(person2); // true
// ES5 的方法 Object.getPrototypeOf()，可以返回 [[Prototype]] 的值
Object.getPrototypeOf(person1) == Person.prototype; // true
Object.getPrototypeOf(person1).name; // "x"</pre>
          <p><strong>JS引擎查找对象属性的过程：实例 - 原型对象 - undefined。</strong>这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p>
          <p>在对象实例中不可以重写原型中的值。如果向实例中添加了一个与原型中同名的属性，那么就会在实例中创建该属性，该属性则会“屏蔽”原型中的那个属性。</p>
          <pre class="prettyprint">
var person1 = new Person();
var person2 = new Person();

person1.name = 'b';
person1.name; // "b" ——来自实例
person2.name; // "x" ——来自原型
delete person1.name;
person1.name; // "x" ——来自原型</pre>
          <p>用 delete 操作符删除实例中的属性后，“屏蔽”也就消失了，再访问该属性时就是原型中的值了。</p>
          <p>Object 的 hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是原型中。这个方法只在给定属性存在于对象实例中，才会返回 true 。</p>
          <pre class="prettyprint">
var person1 = new Person();
var person2 = new Person();

person1.hasOwnProperty('name'); // false 即属性来自原型
person1.name = 'b'; // 创建实例属性
person1.hasOwnProperty('name'); // true 即属性来自实例</pre>
        </li>
        <li>
          <h4>原型与 in 操作符</h4>
          <p> in 操作符有两种用法：for-in循环，单独使用。单独使用时，'name' in object 可以访问到属性时返回 true ，无论属性存在于实例还是原型中。</p>
          <p>利用 in 和 hasOwnProperty() 方法，可以确定该属性是否存在于原型中：</p>
          <pre class="prettyprint">
// 检测属性是否是来自于原型
function hasPrototypeProperty(object, name) {
  // 判断属性是否存在于对象实例中
  // 存在则直接返回 false;
  // 不存在，则再判断是否（原型中）可以访问到该属性
  // 可访问到，返回 true,
  return !object.hasOwnProperty(name) && (name in object);
}
var person = new Person();
hasPrototypeProperty(person, 'name'); // true
person.name = 'b';
hasPrototypeProperty(person, 'name'); // false</pre>
          <p>使用ES5的 Object.keys() 可取得对象上所有可枚举的实例属性，此方法接受一个对象参数，返回字符串数组。<br>使用ES5的 Object.getOwnPropertyNames() 可取得对象上所有的实例属性。</p>
          <pre class="prettyprint">
Object.keys(Person.prototype); // ["name", "age", "job", "sayName"]
Object.getOwnPropertyNames(Person.prototype); // ["constructor", "name", "age", "job", "sayName"]</pre>
        </li>
        <li>
          <h4>更简单的原型语法</h4>
          <p>用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p>
          <pre class="prettyprint">
function Person() {}
Person.prototype = {
  name: 'x',
  age: 22,
  job: 'F2E',
  sayName: function() {
    console.log(this.name);
  }
};

// 这种方法，可以将 Person.prototype 设置为对象字面量形式创建的新对象。
// 但是 constructor 属性不再指向 Person 了。
// 此时的 constructor 指向新对象的 constructor 属性（Object构造函数）

var friend = new Person();
friend instanceof Object; // true
friend instanceof Person; // true
friend.constructor === Person; // false
friend.constructor === Object; // true

// 如果 constructor 属性很重要，可以像下面这样特意将它设置回适当的值。
Person.prototype = {
  constructor: Person, // [[Enumerable]]特性为 true，即可枚举
  name: 'x',
  age: 22,
  job: 'F2E',
  sayName: function() {
    console.log(this.name);
  }
};
// 可以用 defineProperty 来设置 constructor 为不可枚举
Person.prototype = {
  name: 'x',
  age: 22,
  job: 'F2E',
  sayName: function() {
    console.log(this.name);
  }
};
Object.defineProperty(Person.prototype, 'constructor', {
  enumerable: false,
  value: Person
})</pre>
          <p></p>
        </li>
        <li>
          <h4>原型的动态性</h4>
          <p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例中反映出来。</p>
          <pre class="prettyprint">
var friend = new Person();
Person.prototype.sayHi = function() { console.log('hi'); };
friend.sayHi(); // "hi"</pre>
        </li>
        <li>
          <h4>原生对象的原型</h4>
          <p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。</p>
          <p>所有原生引用类型（ Object, Array, String 等）都在其构造函数的原型上定义了方法。</p>
          <pre class="prettyprint">
typeof Array.prototype.sort; // "function"
typeof String.prototype.substring; // "function"</pre>
          <p>通过原生对象的原型，还可以定义新方法：</p>
          <pre class="prettyprint">
String.prototype.startsWith = function(text) {
  return this.indexOf(text) === 0;
};
var msg = 'Hello world';
msg.startsWith('Hello'); // true</pre>
        </li>
        <li>
          <h4>原型对象的问题</h4>
          <p>原型模式最大的问题是由其共享的本性所导致的。</p>
          <p>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说的过去，毕竟通过在实例上添加一个同名属性，可以「隐藏」原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了：</p>
          <pre class="prettyprint">
function Person() {}

Person.prototype = {
  constructor: Person,
  name: 'x',
  age: 22,
  job: 'F2E',
  friends: ['w', 'y'],
  sayName: function() { console.log(this.name); }
};

var person1 = new Person();
var person2 = new Person();

person1.friends.push('z');

person1.friends; // ["w", "y", "z"]
person2.friends; // ["w", "y", "z"]
person1.friedns === person2.friends; // true</pre>
          <p>Person 的两个实例中 friends 属性指向同一个数组，即所有的 Person 实例都会共享这个数组。但是，实例一般都是要有属于自己的属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。</p>
        </li>
      </ol>
    </div>
  </div>
  <div id="constructor_prototypeMixed" class="exp-container">
    <h3 class="exp-title-sub">组合式用构造函数模式和原型模式</h3>
    <div class="exp-stage">
      <p>组合式用构造函数模式与原型模式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。结果，每个实例对象都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混合模式还支持向构造函数传递参数：</p>
      <pre class="prettyprint">
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.friends = ["a", "b"];
}
Person.prototype = {
  constructor: Person,
  sayName: function() {
    console.log(this.name);
  }
};

var person1 = new Person('x', 22, 'F2E');
var person2 = new Person('y', 20, 'DBA');

person1.friends.push('z');
person1.friends; // ["a", "b", "z"]
person2.friends; // ["a", "b"]
person1.friends === person2.friends; // false
person1.sayName === person2.sayName; // true</pre>
      <p>这种构造函数与原型混合的模式，是前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，着使用来定义引用类型的一种默认模式。</p>
    </div>
  </div>
  <script src="https://rawgit.com/blade254353074/FED-Learn-Path/gh-pages/assets/js/libs/prettify.js"></script>
</body>

</html>
